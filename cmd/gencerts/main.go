package main

import (
	"fmt"
	"net"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"

	"network-tunneler/pkg/crypto"
)

var (
	org           string
	outputDir     string
	generateEmbed bool
)

func main() {
	rootCmd := &cobra.Command{
		Use:   "gencerts",
		Short: "Generate TLS certificates for network tunneler",
		Run:   run,
	}

	rootCmd.Flags().StringVar(&org, "org", "Network Tunneler", "Organization name")
	rootCmd.Flags().StringVar(&outputDir, "output", "internal/certs", "Output directory for certificates")
	rootCmd.Flags().BoolVar(&generateEmbed, "embed", true, "Generate Go file with embedded certificates")

	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}

func run(cmd *cobra.Command, args []string) {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create output directory: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Generating CA...")
	ca, err := crypto.GenerateCA(org)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to generate CA: %v\n", err)
		os.Exit(1)
	}

	caPath := filepath.Join(outputDir, "ca.crt")
	caKeyPath := filepath.Join(outputDir, "ca.key")
	if err := ca.SaveToFiles(caPath, caKeyPath); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to save CA: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("  CA certificate: %s\n", caPath)
	fmt.Printf("  CA private key: %s\n", caKeyPath)

	fmt.Println("\nGenerating server certificate...")
	serverCert, serverKey, err := crypto.GenerateCert(ca, crypto.CertOptions{
		CommonName: "server",
		DNSNames:   []string{"localhost", "server"},
		IPAddr:     []net.IP{net.ParseIP("127.0.0.1"), net.ParseIP("::1")},
		Type:       crypto.ServerCert,
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to generate server certificate: %v\n", err)
		os.Exit(1)
	}

	serverCertPath := filepath.Join(outputDir, "server.crt")
	serverKeyPath := filepath.Join(outputDir, "server.key")
	if err := crypto.SaveCert(serverCert, serverKey, serverCertPath, serverKeyPath); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to save server certificate: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("  Server certificate: %s\n", serverCertPath)
	fmt.Printf("  Server private key: %s\n", serverKeyPath)

	fmt.Println("\nGenerating client certificate...")
	clientCert, clientKey, err := crypto.GenerateCert(ca, crypto.CertOptions{
		CommonName: "client",
		DNSNames:   []string{"client"},
		Type:       crypto.ClientCert,
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to generate client certificate: %v\n", err)
		os.Exit(1)
	}

	clientCertPath := filepath.Join(outputDir, "client.crt")
	clientKeyPath := filepath.Join(outputDir, "client.key")
	if err := crypto.SaveCert(clientCert, clientKey, clientCertPath, clientKeyPath); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to save client certificate: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("  Client certificate: %s\n", clientCertPath)
	fmt.Printf("  Client private key: %s\n", clientKeyPath)

	fmt.Println("\nGenerating proxy certificate...")
	proxyCert, proxyKey, err := crypto.GenerateCert(ca, crypto.CertOptions{
		CommonName: "proxy",
		DNSNames:   []string{"proxy"},
		Type:       crypto.ClientCert,
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to generate proxy certificate: %v\n", err)
		os.Exit(1)
	}

	proxyCertPath := filepath.Join(outputDir, "proxy.crt")
	proxyKeyPath := filepath.Join(outputDir, "proxy.key")
	if err := crypto.SaveCert(proxyCert, proxyKey, proxyCertPath, proxyKeyPath); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to save proxy certificate: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("  Proxy certificate: %s\n", proxyCertPath)
	fmt.Printf("  Proxy private key: %s\n", proxyKeyPath)

	fmt.Println("\nCertificates generated successfully!")
	fmt.Printf("\nAll certificates saved to: %s\n", outputDir)

	if generateEmbed {
		fmt.Println("\nGenerating Go embed file...")
		if err := generateEmbedFile(outputDir); err != nil {
			fmt.Fprintf(os.Stderr, "Failed to generate embed file: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("  Go embed file: %s\n", filepath.Join(outputDir, "embed.go"))
	}

	fmt.Println("\nTo use embedded certificates, import:")
	fmt.Println("  import \"network-tunneler/internal/certs\"")
}

func generateEmbedFile(dir string) error {
	content := `// Code generated by gencerts. DO NOT EDIT.

package certs

import _ "embed"

// CA Certificate
//go:embed ca.crt
var CACert string

//go:embed ca.key
var CAKey string

// Server Certificate
//go:embed server.crt
var ServerCert string

//go:embed server.key
var ServerKey string

// Client Certificate
//go:embed client.crt
var ClientCert string

//go:embed client.key
var ClientKey string

// Proxy Certificate
//go:embed proxy.crt
var ProxyCert string

//go:embed proxy.key
var ProxyKey string
`

	embedPath := filepath.Join(dir, "embed.go")
	if err := os.WriteFile(embedPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write embed file: %w", err)
	}

	return nil
}
